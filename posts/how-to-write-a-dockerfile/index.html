<!doctype html><html lang=ja><head><title>Dockerfileを書いてみよう :: blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="はじめに Dockerfileを使ったイメージの作成と起動について人に教える機会も増えてきたこともあり、毎回アドリブでやるのもつらいし日によって質のブレも出てくるので、ここらでいったん文書化することにしました。 想定読者はDockerなんもわからんのでやってみながら覚えたい、ふだんはアプリを書くのがメインな人です。 基本的なshellでの操作(cd, mv, cpなど)はできるものとし、また、Dockerはイン"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/posts/how-to-write-a-dockerfile/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/blue.css><link rel=apple-touch-icon href=/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=/img/favicon/blue.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="kei"><meta property="og:locale" content="ja"><meta property="og:type" content="article"><meta property="og:title" content="Dockerfileを書いてみよう"><meta property="og:description" content="はじめに Dockerfileを使ったイメージの作成と起動について人に教える機会も増えてきたこともあり、毎回アドリブでやるのもつらいし日によって質のブレも出てくるので、ここらでいったん文書化することにしました。 想定読者はDockerなんもわからんのでやってみながら覚えたい、ふだんはアプリを書くのがメインな人です。 基本的なshellでの操作(cd, mv, cpなど)はできるものとし、また、Dockerはイン"><meta property="og:url" content="/posts/how-to-write-a-dockerfile/"><meta property="og:site_name" content="blog"><meta property="og:image" content="/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:section" content="技術"><meta property="article:published_time" content="2022-03-28 02:30:00 +0900 +0900"><script data-goatcounter=https://k16em.goatcounter.com/count async src=//gc.zgo.at/count.js></script></head><body class=blue><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>blog</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/categories>カテゴリ</a></li><li><a href=/tags>タグ</a></li><li><a href=/archives>月別アーカイブ</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/categories>カテゴリ</a></li><li><a href=/tags>タグ</a></li><li><a href=/archives>月別アーカイブ</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=/posts/how-to-write-a-dockerfile/>Dockerfileを書いてみよう</a></h1><div class=post-meta><span class=post-date>2022-03-28</span>
<span class=post-author>:: kei</span></div><span class=post-tags>#<a href=/tags/docker/>docker</a>&nbsp;</span><div class=post-content><div><h2 id=はじめに>はじめに<a href=#はじめに class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Dockerfileを使ったイメージの作成と起動について人に教える機会も増えてきたこともあり、毎回アドリブでやるのもつらいし日によって質のブレも出てくるので、ここらでいったん文書化することにしました。<br>想定読者はDockerなんもわからんのでやってみながら覚えたい、ふだんはアプリを書くのがメインな人です。<br>基本的なshellでの操作(cd, mv, cpなど)はできるものとし、また、<code>Docker</code>はインストール済みのものとします。<code>compose v2</code>および<code>docker-compose</code>には触れません。<br>最終的に簡単な(<strong>ここ重要</strong>)スクリプト言語の実行環境を作るためのDockerfileを書くことができるようになることが目的です。
題材にはPythonを使います。楽なので。<br>また、この記事で実行するコマンドはlinux上で実行されています。実行環境によって出力が異なることがありますが、その場合は適宜読み替えをお願いします。</p><h2 id=目次>目次<a href=#目次 class=hanchor arialabel=Anchor>&#8983;</a></h2><ol><li><a href=#docker%E3%81%A8%E3%81%AF>Dockerとは？</a></li><li><a href=#dockerfile%E3%82%92%E6%9B%B8%E3%81%84%E3%81%A6%E3%81%84%E3%81%8F>Dockerfileを書いていく</a><ol><li><a href=#2%E8%A1%8C%E3%81%A7%E5%85%A5%E9%96%80%E3%81%99%E3%82%8B>2行で入門する</a></li><li><a href=#%E8%87%AA%E5%88%86%E7%94%A8%E3%81%AB%E3%82%BF%E3%82%B0%E3%82%92%E8%A8%AD%E5%AE%9A%E3%81%99%E3%82%8B>自分用にタグを設定する</a></li><li><a href=#%E3%82%BD%E3%83%BC%E3%82%B9%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E3%81%AB%E5%90%8C%E6%A2%B1%E3%81%97%E3%81%A6%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%8B%E3%82%89%E5%AE%9F%E8%A1%8C%E3%81%A7%E3%81%8D%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%99%E3%82%8B>ソースファイルをコンテナに同梱して、ファイルから実行できるようにする</a></li><li><a href=#arg%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86>ARGを使ってみよう</a></li><li><a href=#pip%E3%82%92%E4%BD%BF%E3%81%86>pipを使う</a></li></ol></li><li><a href=#%E7%B5%82%E3%82%8F%E3%82%8A%E3%81%AB>終わりに</a></li></ol><h2 id=dockerとは>Dockerとは？<a href=#dockerとは class=hanchor arialabel=Anchor>&#8983;</a></h2><p>そもそもDockerとは？ についてです。<br><a href=https://docs.docker.com/get-started/overview/>公式</a>ドキュメントからわかりやすい部分を引用します(引用は<a href=https://docs.docker.jp/get-started/overview.html>有志日本語訳</a>)。</p><blockquote><p>Docker はアプリケーションの開発、導入、実行を行うためのオープンなプラットフォームです。Docker を使えば、アプリケーションをインフラストラクチャーから切り離すことができるため、ソフトウエアをすばやく提供することができます。Docker であれば、アプリケーションを管理する手法をそのまま、インフラストラクチャーの管理にも適用できます。</p></blockquote><p>これは、より簡単に、こう言い換えることができます。<br><em>Dockerは、任意の必要なソフトウェアだけでアプリケーションの実行を可能<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>にし、開発・運用を簡単にすることが<strong>できる</strong>ものです</em>。</p><p><code>任意の必要なソフトウェアだけでアプリケーションの実行を可能にする</code>とはどういうことでしょうか。<br>一般的に、アプリケーションの実行環境は複数のソフトウェアの集合です。たとえば、「Hello World!」とだけ書かれたwebページを返すだけのPythonで書かれたアプリのことを考えてみてください。これを、Dockerではない通常のLinux環境で実行する場合、どれくらいのソフトウェアが必要になるでしょうか。<br>私もすべてを挙げることはできませんが、すぐに思いつく範囲では下記のようなものがあります。</p><ul><li><code>Python</code>(当然ですね)</li><li><code>sshd</code> or <code>ftp</code>(コードをデプロイするのに必要です)</li><li>なにかしらのネットワークマネージャ</li><li>上記のソフトウェアをインストールするためのパッケージマネージャ(<code>apt</code>や<code>pacman</code>)</li><li>上記のソフトウェアを実行するためのプロセス管理システム(<code>init.d</code>や<code>systemd</code>)</li><li>linux kernel</li></ul><p>上記のソフトウェア群はそれぞれが動作のために別のソフトウェアを要求します。アプリケーションを運用するということは、大量のソフトウェアを運用することです。<br>どこまで厳密にやるかはともかく、パフォーマンスのため、セキュリティレベル維持のため、アプリケーションのソースコードに加えて、これらのうちある程度の管理が必要ということです。具体的には<code>Ansible</code>や<code>Chef</code>などの構成管理ツールや<code>cloud-init</code>などを利用してサーバの状態を一定にしたり、カーネルのバージョンアップをしたり<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>です。<br>このレイヤーの出来事はアプリケーションの健全な実行に必要ですが、開発者としては若干別領域、たとえばインフラエンジニアやSREの領域に見えるため、本格的にやるにはちょっと躊躇する部分かもしれません。<br>ところが、この部分を開発者以外に任せることにすると、別の複数の問題が発生します。たとえば、ミドルウェアレベルの構成変更にチーム外の人間とのやりとりが必要になったり、アプリケーション実行環境の全体像がアプリケーション開発者にぼんやりとしか見えなくなったりです。これらは最終的に開発速度の低下を引き起こします。</p><p>そこで、Dockerの出番というわけです。<br>Docker<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>を利用することで、深いlinuxサーバの知識がなくとも、実行環境を簡単な定義ファイル<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>だけで整えることができるようになります。</p><p>とだけ書くと、まるで夢のような技術に聞こえてしまうのですが、ここで先ほどのテキストの太字部分を思い出してください。</p><blockquote><p>開発・運用を簡単にすることが<strong>できる</strong></p></blockquote><p><strong>できる</strong>とあります。<strong>簡単になる</strong>ではないことに留意してください。<br>DockerにはDockerの作法があり、作法を逸脱するとわりとつらい思いをします。コンテナの概念に慣れていないと、この作法の逸脱をしてしまいがちです。Dockerの不便さを解消しようとするまえに、あなたが不便に思うこと、そして解消したいことがコンテナの考え方に反していないかを考えてみてください。少しオーウェル的ですが、その不便さこそがコンテナの利便性を提供しているものかもしれません<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>。</p><p>それでは、やっていきましょう</p><h2 id=dockerfileを書いていく>Dockerfileを書いていく<a href=#dockerfileを書いていく class=hanchor arialabel=Anchor>&#8983;</a></h2><p>扱うファイルが多いので、あらかじめできあがったものを公開しています。必要に応じて参照したり、cloneしてご利用ください。<br><a href=https://github.com/kei-s16/blog-docker-examples>kei-s16/blog-docker-examples</a></p><h3 id=2行で入門する>2行で入門する<a href=#2行で入門する class=hanchor arialabel=Anchor>&#8983;</a></h3><p>このセクションのサンプルは<a href=https://github.com/kei-s16/blog-docker-examples/tree/main/example1>example1</a>にあります。</p><p>Dockerコンテナを起動するためにはコンテナイメージと呼ばれるものが必要で、コンテナイメージを作るためにはDockerfileという定義ファイルを書いてあげる必要があります。このセクションでは、この一連の流れを体験しましょう。</p><p>まずはDockerfileを書いて、コンテナイメージをビルドし、コンテナを立ち上げるためだけの小さなPythonコードを考えます。<br>最初から大きくやるとたいてい失敗するので、極端なほど小さく始めましょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print(<span style=color:#e6db74>&#34;Hello World!&#34;</span>)
</span></span></code></pre></div><p>はい、Hello Worldです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>python -c <span style=color:#e6db74>&#39;print(&#34;Hello World!&#34;)&#39;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>% python -c <span style=color:#e6db74>&#39;print(&#34;Hello World!&#34;)&#39;</span>
</span></span><span style=display:flex><span>Hello World!
</span></span></code></pre></div><p>まごうことなきHello Worldですね。<br>まずはこのコマンドをそのままコンテナ環境で実行できるようにしていきましょう。<br>作業ディレクトリに、Dockerfileという名前のファイルを作成し、内容を下記の通りに編集してください。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> python:3.10.4-bullseye</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;python&#34;</span>, <span style=color:#e6db74>&#34;-c&#34;</span>, <span style=color:#e6db74>&#34;print(&#39;Hello World!&#39;)&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>1行目は、<code>FROM</code>というベースとなるイメージを取得してくるコマンドを実行しています。値として、<code>イメージ名:タグ(任意)</code>の形式の文字列を与えることで、コンテナレジストリ<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>からイメージをダウンロードしてきます(Dockerではこれを<code>pull</code>といいます)。また、タグが明示的に指定されなかった場合(今回であれば、<code>FROM python</code>)には、最新のイメージ(<code>latest</code>タグのイメージ)が指定されたものとして振る舞います。
今回は、<code>Python</code>が実行できるイメージのうち、Pythonのバージョンが3.10.4でdebianのbullseyeならだいたい入ってそうなパッケージの詰まったもの(<code>3.10.4-bullseye</code>)を持ってくるようにしています。<br>こうしたコンテナイメージは、<a href=https://hub.docker.com/>Dockerhub</a>で探すことができます。</p><p>2行目は、<code>CMD</code>コマンドです。<code>CMD</code>はDockerfileの中で一度しか使えないコマンドで、コンテナ起動時のデフォルトの挙動を定義します。今回はPythonでprintを実行するコマンドをデフォルトで定義しているので、コマンドの上書きをして実行をしなければ、コンテナ起動時にHello World! とプリントされます。<code>CMD</code>には値として、<code>実行したいコマンドをスペース区切りごとにダブルクォートで括ったもの</code>を<code>[]</code>で括った文字列を渡します。</p><p>では、このDockerfileをビルドして、ビルドしたイメージを起動してみましょう。</p><p>まずはこのコマンドでビルドします。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>% docker build -f ./Dockerfile .
</span></span></code></pre></div><p>おそらく、末尾に下記のような文言が出力されるはずです。IMAGE IDの部分を控えておいてください。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Successfully built <span style=color:#f92672>{</span>IMAGE ID<span style=color:#f92672>}</span>
</span></span></code></pre></div><p>(ここから追記)</p><p>Docker for Macを使っている場合はこの部分の出力が違うそうです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>=</span>&gt; exporting to image 0.0s
</span></span><span style=display:flex><span><span style=color:#f92672>=</span>&gt; <span style=color:#f92672>=</span>&gt; exporting layers 0.0s
</span></span><span style=display:flex><span><span style=color:#f92672>=</span>&gt; <span style=color:#f92672>=</span>&gt; writing image <span style=color:#f92672>{</span>IMAGE ID<span style=color:#f92672>}</span>
</span></span></code></pre></div><p>(ここまで追記)</p><p>次に、このコマンドを実行することでコンテナが起動します。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>% docker run <span style=color:#f92672>{</span>IMAGE ID<span style=color:#f92672>}</span>
</span></span></code></pre></div><p>どうですか？ <code>Hello World!</code> と出力され、正常に処理が終了したためコンテナも終了し、ターミナルに戻ったはずです。Dockerfileを書いて、コンテナイメージをビルドし、コンテナを立ち上げるという一連の流れを体験することができましたね！</p><h3 id=自分用にタグを設定する>自分用にタグを設定する<a href=#自分用にタグを設定する class=hanchor arialabel=Anchor>&#8983;</a></h3><p>ところで、先ほどの手順でIMAGE IDを利用するのが面倒ではありませんでしたか？<br>実は、<code>--tag</code>(省略形は<code>-t</code>)オプションを使うことで自分用にタグをつけることができ、そのタグを使ってコンテナイメージを指定することができます。
たとえばこんな感じです。</p><pre tabindex=0><code>% docker build -f ./Dockerfile --tag=&#34;python-tutorial:step1&#34;.
% docker run python-tutorial:step1
</code></pre><h3 id=ソースファイルをコンテナに同梱してファイルから実行できるようにする>ソースファイルをコンテナに同梱して、ファイルから実行できるようにする<a href=#ソースファイルをコンテナに同梱してファイルから実行できるようにする class=hanchor arialabel=Anchor>&#8983;</a></h3><p>このセクションのサンプルは<a href=https://github.com/kei-s16/blog-docker-examples/tree/main/example2>example2</a>にあります。</p><p>さきほどの手順では、コマンドラインから渡す形式でしかPythonスクリプトを実行することができませんでした。<br>しかし、実際のアプリケーションは複数のコマンドからなるため、ファイルにまとめられているはずです。さきほどの手順では、本格的なアプリケーションが実行できないのです<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>。<br>というわけで、このセクションではソースファイルからアプリを実行できるDockerコンテナを作成してみます。</p><p>前のセクションで使ったDockerfileを編集するか、新しく作業ディレクトリを作成してDockerfileという名前のファイルを作成するかのどちらかを実施し、内容を下記の通りにしてください(改行は省略してもかまいません)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> python:3.10.4-bullseye</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /usr/src/app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> ./src .<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;python&#34;</span>, <span style=color:#e6db74>&#34;./main.py&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>その後、Dockerfileのあるディレクトリに<code>src</code>という名前のディレクトリを作成し、その中に<code>main.py</code>というファイルを作成してください。中身は下記のように編集してください。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print(<span style=color:#e6db74>&#34;Hello World!&#34;</span>)
</span></span></code></pre></div><p>さて、ここまでの手順で、作業ディレクトリの構造はこのようになっているはずです。</p><pre tabindex=0><code>- 作業ディレクトリ
  - Dockerfile
  - src
    - main.py
</code></pre><p>ディレクトリの中身が正しいことを確認したら、下記のコマンドを実行して、どうなるか見てみましょう。</p><pre tabindex=0><code>% docker build -f ./Dockerfile --tag=&#34;python-tutorial:step2&#34; .
% docker run python-tutorial:step2
</code></pre><p>どうでしたか？ <code>Hello World!</code> と出力されましたか？</p><p>ではここで、Dockerfileの中に書いた、新しいコマンドについて説明します。<br><code>WORKDIR</code>は、Dockerfileに書かれたコマンドを実行するディレクトリを変更するコマンドです。たとえば、<code>WORKDIR /usr/src/app</code>を実行したあとの処理で<code>pwd</code>を実行すれば<code>/usr/src/app</code>と出力されますし、<code>cat ./hoge</code>とすれば<code>/usr/src/app/hoge</code>を出力しようとします。また、<code>WORKDIR</code>で存在するディレクトリを指定するとそのディレクトリに移動するだけですが、存在しないディレクトリを指定した場合は、移動先のディレクトリを作成してから移動します。<br><code>COPY</code>は、コンテナをビルドする環境のファイルシステムから、コンテナに対してファイルをコピーするコマンドです。<code>COPY ./src .</code>は、ビルド環境のカレントディレクトリにある<code>src</code>ディレクトリを、コンテナのカレントディレクトリにコピーすることを意味します。</p><p>これを踏まえて今回のDockerfileを読むと、</p><ol><li><code>/usr/src/app</code>に移動する</li><li>ホストマシンの<code>./src</code>から<code>/usr/src/app</code>にファイルをコピーする</li><li>デフォルトでは<code>python /usr/src/app/main.py</code>を実行するように設定する</li></ol><p>という処理がビルド時に実行されることがわかります。</p><p>注意点として、あたりまえですが<code>COPY</code>したファイルはコンテナイメージに含まれます。コンテナイメージをダウンロードした人は誰でもコンテナの中に置かれたファイルを見ることができるようになるということです。業務でも個人プロジェクトでもそうですが、機密情報はコンテナイメージの外(S3やDBなど)に持つようにする、<code>ENV</code>コマンドを使うことで環境変数として起動時に初めて渡すようにし、イメージ内部には持たないようにするなどしましょう。そもそも機密を含むものが誰でも利用できるようになること自体避けたいわけですが(プロダクション用のイメージなどはプライベートレジストリを使うべきです)。</p><h3 id=argを使ってみよう>ARGを使ってみよう<a href=#argを使ってみよう class=hanchor arialabel=Anchor>&#8983;</a></h3><p>ここまで書いたDockerfileはすべてタグを固定で書いています。別のイメージを試したくなったときはDockerfileに手を加える必要があるわけですが、試すだけなのにエディタを開くのはちょっとおっくうです。<br>そこで、ビルドコマンドの引数でタグを渡してあげればいい感じに<code>FROM</code>で持ってくるイメージを変えることができるようにしてみましょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>ARG</span> TAG<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;3.10.4-bullseye&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> python:$TAG</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /usr/src/app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> ./src .<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;python&#34;</span>, <span style=color:#e6db74>&#34;./main.py&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>新しく追加した<code>ARG</code>コマンドは、ビルド時に受けつける追加の引数名と、そのデフォルト値を定義できるコマンドです。例では、<code>TAG</code>という引数を受けつけるようにし、その引数が与えられなかった場合は<code>python:3.10.4-bullseye</code>が与えられたものとして振る舞うように設定されています。そして、<code>TAG</code>は<code>FROM</code>コマンドで利用されています。これで、ビルド時の引数としてイメージタグを受け取れるようになったわけです。<br>引数は<code>--build-arg</code>オプションで与えます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>% docker build -f ./Dockerfile --tag<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;python-tutorial:extra&#34;</span> --build-arg TAG<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;3.11-rc-bullseye&#34;</span>.
</span></span></code></pre></div><p>ユースケースとしては、上記の例のように実行環境を気軽に上げて検証できるようにする、などがあります。その他にも、様々な使い方があります。いずれ活用してみてください。</p><h3 id=pipを使う>pipを使う<a href=#pipを使う class=hanchor arialabel=Anchor>&#8983;</a></h3><p>このセクションのサンプルは<a href=https://github.com/kei-s16/blog-docker-examples/tree/main/example3>example3</a>にあります。</p><p>ここまでである程度ちゃんとしたPythonの実行を作成できるようになりましたが、なにか抜けていませんか？ そう、外部パッケージの利用です。<br>愚直な方法はビルドを実行するマシンで<code>pip install</code>して、それを参照することですが、なんというかいろいろ問題がありますね。pipを使ううまみがほとんどないというか……。<br>でも、現時点で私たちが知っているビルドにコマンドを実行する方法は<code>CMD</code>コマンドだけです。ここにコマンドを書いても、実行時コマンドの上書きで実行されない可能性がありますし、なにより<code>CMD</code>はDockerfileのなかで一度しか使うことができません。<br>というわけで、<code>CMD</code>以外のコマンドを使って、コンテナらしくビルド中に<code>pip</code>を使えるようにし、コンテナ上のPythonで外部パッケージを扱ってみましょう。</p><p>今回は、<a href=https://pypi.org/project/colorama/>colorama</a>を利用して、文字列を赤く出力してみます。<br><a href=https://github.com/kei-s16/blog-docker-examples/tree/main/example3>example3</a>を参考に、お手元に必要なファイルを用意し、ビルドと実行をしてみてください。うまくいけば、赤文字でHello World! と表示されるはずです。</p><p>さて、どうやって<code>pip install</code>と<code>python main.py</code>のふたつを実行できるようにしたのでしょうか？ 答えはこの行にあります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Dockerfile data-lang=Dockerfile><span style=display:flex><span><span style=color:#66d9ef>RUN</span> pip install --no-cache-dir -r requirements.txt<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>ここで登場する<code>RUN</code>というコマンドは、コンテナのビルドの途中で任意のコマンドを実行するために使われます。<code>CMD</code>と違い、コマンドはふだんシェルで入力する形で与えることもできます。<code>CMD</code>で実行する処理に必要な前準備は、<code>RUN</code>を使って記述します。たとえば、今回のようなアプリケーションが利用する外部パッケージのインストールのほか、外部サービスから設定をダウンロードしてきたり、ソースコードから実行可能なバイナリをビルドしたりするのには<code>RUN</code>コマンドを使うといいと思います<sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>。</p><h2 id=終わりに>終わりに<a href=#終わりに class=hanchor arialabel=Anchor>&#8983;</a></h2><p>今回は、基本的なアプリケーションを実行するために必要な最低限のDockerfile知識をまとめました。<br>この次のステップは、自分のサービスを動かしてみることになると思います。そのステップをやりきるには、この記事にある情報だけでは難しいと思います。公式ドキュメントに軽く目を通しながら進めていくことを強くおすすめします。<br>また、記事では触れませんでしたが、リポジトリには<code>ステージ</code>とそれを活用した<code>マルチステージビルド</code>の例も置いています<sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>。気になる方はどうぞ。</p><p>コメントや誤りの連絡は、<a href=https://github.com/kei-s16/kei-s16.github.io/issues/new>issue</a>にお願いします。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>厳密には、<code>カーネルレベルの依存関係をすべてホストマシンに委ねることで、Dockerを利用している開発者の視点では任意の必要なソフトウェアだけでのアプリケーションの実行が可能になっているように見える</code>。Dockerの実行環境自身がときどきこのあたり意識することを要求してくる。ECSやCloud Runなどのマネージドなコンテナ実行環境を利用するなら、この部分はクラウド事業者が管理してくれるのである程度無視できる。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>このセクションには理想が多分に含まれている。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>厳密にはコンテナ仮想化技術。&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>誰向けなのかわからない注釈 : Vagrantfileのようなものを想像するとわかりやすい。&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>なんでこんなことを書いているのかって？ ひどい目にあったからですよ(なんもわかってないときに書いたDockerfileを直しながら)。&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>タグだけ与えた場合はデフォルトではDockerhubから取得してくる。URIを与えることで、任意のコンテナレジストリ<sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>から取得することができる。&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>ここでワンライナーを持ち出すのはやめてください。&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>とはいえ、<code>RUN</code>にはビルドの仕組みを知らないとひっかかりやすい落とし穴があったりする。ガリガリ書き始めるまえに、公式ドキュメントを読むことをおすすめします。&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p>途中で力尽きたとも言う。想定読者的にはまだいらんじゃろという気持ちもある&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p>Elastic Container Registry, Github Contgainer Registry, 自宅に立てたオレオレレジストリなど。&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/isu12q-report/><span class=button__icon>←</span>
<span class=button__text>ISUCON初参加のふりかえり</span></a></span>
<span class="button next"><a href=/posts/hugo-on-github-pages/><span class=button__text>Github PagesにHugoをデプロイする</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=/assets/main.js></script>
<script src=/assets/prism.js></script></div></body></html>